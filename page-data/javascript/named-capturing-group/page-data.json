{"componentChunkName":"component---src-templates-post-jsx","path":"/javascript/named-capturing-group/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"마법같은 정규 표현식","date":"August 07, 2023","series":"JavaScript","icon":"TbBrandJavascript","tags":["JavaScript","정규 표현식"]},"fields":{"slug":"/javascript/named-capturing-group/"},"html":"<h1 id=\"블로깅-시작-전에\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9C%EA%B9%85-%EC%8B%9C%EC%9E%91-%EC%A0%84%EC%97%90\" aria-label=\"블로깅 시작 전에 permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블로깅 시작 전에</h1>\n<p>프로그래머스 문제를 많이 접하면서 <code>정규 표현식</code>의 존재를 알게 되었습니다. 이전에 프로젝트 진행 과정에서 이메일 혹은 비밀번호나 아이디 등을 사용자가 입력했을 때, 해당 입력값이 적합한지 판단하게 위해서 <code>정규 표현식</code>을 사용하기도 했었습니다.</p>\n<br/>\n<p>하지만 매번 <code>정규 표현식</code>을 사용할 때, 단순히 구글링을 통해서 긁어와 사용해왔습니다. 이렇게 미루어왔던 <code>정규 표현식</code>에 대해 알아보고 넘어가고자 포스팅을 진행하게 되었습니다.</p>\n<br/>\n<p>그리고 이번 포스팅의 주제처럼 <strong>정말 마법같은 정규 표현식의 기능 중 하나</strong>인 <code>Named Capturing Group</code>에 대해서도 함께 알아보겠습니다.</p>\n<h1 id=\"regular-expression\" style=\"position:relative;\"><a href=\"#regular-expression\" aria-label=\"regular expression permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Regular Expression?</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 708px; margin: 0.25rem 0; padding: 0;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b8228782d32af97b9d8b5ec7afbefcf9/68934/regexp.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.983050847457626%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4klEQVR42qVRSQqEMBDM//8lKOhBb3oSwQ33BXetoRoiwzCMh2kok1RXl+m0atsWfd9jGAZ0XSfrsiyYpglN04D595Vgbp5n0RLjOEqenNKHJElETEFZlsL5vg/DMGDbNizLgmmaCIIAdV2jKAq5COuiKJLafd+haEABE1VViWjbNrklix3Hged5cF1XQI754zhuwzAMpZa84kfHdV0CHed5ypnFbGdd15v71OtV8ZpPQRP9xk/x01C3lee5tERTcn8Z8i35TlmWSduPhhTy75zsJzjJOI6RpqmAe3LftAQn/QIIaWfZ3vVlJwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"regexp\"\n        title=\"\"\n        src=\"/static/b8228782d32af97b9d8b5ec7afbefcf9/d65de/regexp.png\"\n        srcset=\"/static/b8228782d32af97b9d8b5ec7afbefcf9/ad6ca/regexp.png 177w,\n/static/b8228782d32af97b9d8b5ec7afbefcf9/16bd5/regexp.png 354w,\n/static/b8228782d32af97b9d8b5ec7afbefcf9/d65de/regexp.png 708w,\n/static/b8228782d32af97b9d8b5ec7afbefcf9/3e86e/regexp.png 1062w,\n/static/b8228782d32af97b9d8b5ec7afbefcf9/68934/regexp.png 1278w\"\n        sizes=\"(max-width: 708px) 100vw, 708px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br/>\n<p><code>Regular Expression</code>, 다른 말로 <code>정규 표현식</code>은 <strong>특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어</strong>입니다. 여기서 형식 언어는 다음과 같은 의미를 가지고 있습니다.</p>\n<br/>\n<blockquote>\n<p><a href=\"https://ko.wikipedia.org/wiki/%ED%98%95%EC%8B%9D_%EC%96%B8%EC%96%B4\"><strong>형식 언어 - formal language</strong></a></p>\n<ul>\n<li>특정한 법칙들에 따라 적절하게 구성된 문자열들의 집합을 말한다.</li>\n</ul>\n</blockquote>\n<br/>\n<p>쉽게 말하자면 <strong>문자열의 특정 형식</strong>을 <strong>표현할 수 있는 방법</strong>이라고 할 수도 있겠습니다. 초반에는 텍스트 편집기에서의 패턴 매칭으로 사용되었기도 하였으며, 수학적인 의미로 시작되었다고 합니다. 지금은 프로그래밍 언어에서 문자열 검색과 치환을 위해서도 사용되고 있습니다.</p>\n<br/>\n<p>정규 표현식을 사용하면 문자열에 대한 특정 조건을 매우 간단하게 표현할 수 있지만, 특정 표현이 있기 때문에 정규 표현식을 모른다면 이를 이해할 수 없습니다. 이러한 정규 표현식은 <code>meta 문자</code>로 구성되어 있습니다.</p>\n<h2 id=\"meta-문자\" style=\"position:relative;\"><a href=\"#meta-%EB%AC%B8%EC%9E%90\" aria-label=\"meta 문자 permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>meta 문자</h2>\n<blockquote>\n<p><strong>meta 문자</strong></p>\n<ul>\n<li>표현식 내부에서 특정한 의미를 갖는 문자(기호)</li>\n</ul>\n</blockquote>\n<br/>\n<p>좀 더 정리하자면, 단순 문자가 아닌 다른 용도로 사용되는 문자를 말합니다. 단일 문자 또는 <code>\\</code> 가 붙은 단일 문자의 형태로 사용됩니다. 메타 문자는 검사 범위를 지정하거나 수량 혹은 검사 위치를 나타내기도 합니다. 이에 대한 내용을 정리하자면 아래와 같습니다.</p>\n<h3 id=\"정규-표현식-정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%95%EB%A6%AC\" aria-label=\"정규 표현식 정리 permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정규 표현식 정리</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">표현식</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>^x</code></td>\n<td>문자열의 시작을 표현. x 문자로 시작됨을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x$</code></td>\n<td>문자열의 종료를 표현. x 문자로 종료됨을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>.x</code></td>\n<td>임의의 한 문자의 자리수를 표현하며 문자열이 x 로 끝난다는 것을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x+</code></td>\n<td>반복을 표현하며 x 문자가 한 번 이상 반복됨을 의미 (1개 이상)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x?</code></td>\n<td>존재 여부를 표현하며 x 문자가 존재할 수도 아닐 수도 있음</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x*</code></td>\n<td>반복 여부를 표현하며 x 문자가 0번 또는 그 이상 반복됨을 의미 (0개 이상)</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x</code>|<code>y</code></td>\n<td>or 를 표현하며 x 또는 y 문자가 존재함을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>(x)</code></td>\n<td>그룹을 표현하며 x 를 그룹으로 처리함을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>(x)(y)</code></td>\n<td>그룹들의 집합을 표현하며, 앞부터 순서대로 번호를 부여하여 관리. x, y는 각 그룹의 데이터로 관리됨.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>(x)(?:y)</code></td>\n<td>그룹들의 집합에 대한 예외를 표현하며 그룹 집합으로 관리되지 않음을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x{n}</code></td>\n<td>반복을 표현하며 x 문자가 n번 반복됨을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x{n,}</code></td>\n<td>반복을 표현하며 x 문자가 n번 이상 반복됨을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>x{n,m}</code></td>\n<td>반복을 표현하며 x 문자가 최소 n번 이상 최대 m 번 이하로 반복됨을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[xy]</code></td>\n<td>문자 선택을 표현하며 x 와 y 중 하나를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>^xy</code></td>\n<td>not 을 표현하며 x 및 y 를 제외한 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>[x-z]</code></td>\n<td>range 를 표현하며 x ~ z 사이의 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\^</code></td>\n<td>escape 를 표현하며 ^ 를 문자로 사용함을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\b</code></td>\n<td>word boundary 를 표현하며 문자와 공백 사이의 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\B</code></td>\n<td>non word boundary 를 표현하며 문자와 공백 사이가 아닌 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\d</code></td>\n<td>digit 를 표현하며 숫자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\D</code></td>\n<td>non digit 를 표현하며 숫자가 아닌 것을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\s</code></td>\n<td>space 를 표현하며 공백 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\S</code></td>\n<td>non Space 를 표현하며 공백 문자가 아님을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\t</code></td>\n<td>tab 을 표현하며 탭 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\v</code></td>\n<td>vertical tab 을 표현하며 수직 탭 문자를 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\w</code></td>\n<td>word 를 표현하며 알파벳, 숫자, _ 중의 한 문자임을 의미</td>\n</tr>\n<tr>\n<td align=\"center\"><code>\\W</code></td>\n<td>non word 를 표현하며 word 가 아닌 문자를 의미</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>해당 내용은 <a href=\"https://hamait.tistory.com/342\">이 블로그</a>를 참고하여 작성하였습니다.</p>\n</blockquote>\n<h3 id=\"flag\" style=\"position:relative;\"><a href=\"#flag\" aria-label=\"flag permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Flag</h3>\n<p>정규 표현식을 사용함에 있어 <code>Flag</code>를 사용할 수 있습니다. <code>Flag</code>는 특정 의미를 가지고 있으며, <code>Flag</code>를 사용하지 않는 경우에는 문자열에 대한 검색을 한 번만 처리하고 종료하게 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Flag</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>g</code></td>\n<td><code>Global</code> : 대상 문자열 내의 모든 패턴을 검색</td>\n</tr>\n<tr>\n<td align=\"center\"><code>i</code></td>\n<td><code>ignore case</code> : 대상 문자열에서 대/소문자 식별하지 않음</td>\n</tr>\n<tr>\n<td align=\"center\"><code>m</code></td>\n<td><code>Multi line</code> : 대상 문자열이 다중 라인의 문자열인 경우에도 검색</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"regexp-사용법\" style=\"position:relative;\"><a href=\"#regexp-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"regexp 사용법 permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RegExp 사용법</h1>\n<p>그렇다면, 이러한 정규 표현식을 <code>JavaScript</code>에서 어떻게 활용할까요? 관련된 method들을 살펴보겠습니다.</p>\n<h2 id=\"exec\" style=\"position:relative;\"><a href=\"#exec\" aria-label=\"exec permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>exec()</h2>\n<p><code>exec</code>은 <strong>문자열에 대해 특정 부분이 일치하는지를 탐색하여 이에 대한 결과를 알려줍니다</strong>. 결과가 존재하는 경우에는 이에 대한 정보를, 아닌 경우에는 <code>null</code>을 반환하여 이를 바탕으로 특정 문자가 존재하는지 판단할 수 있습니다.</p>\n<br/>\n<p>단순히 일치 여부를 탐색하는 기능에서 더 나아가 <code>global</code> flag를 설정하면 <code>exec</code>을 활용하여 일치하는 각 부분의 index를 탐색할 수 있습니다. <code>g flag</code>를 설정한 regexp로 <code>exec</code>를 실행하면, <code>regexp</code>에서 <code>lastIndex</code>가 변화합니다. 여기서 <code>lastIndex</code>는 바로 이전에 일치한 부분의 index에 대한 정보를 가지고 있습니다.</p>\n<br/>\n<p>예시를 살펴보며 이해해봅시다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// cat 문자열에 대해 global flag를 설정한 정규 표현식</span>\r\n<span class=\"token keyword\">const</span> catRegExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">cat</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"i love cat. cat dominates the world.\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> catRegExp<span class=\"token punctuation\">.</span>lastIndex<span class=\"token punctuation\">)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> catRegExp<span class=\"token punctuation\">.</span>lastIndex<span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\n[\r\n  'cat',\r\n  index: 7,\r\n  input: 'i love cat. cat dominates the world.',\r\n  groups: undefined\r\n] 10\r\n[\r\n  'cat',\r\n  index: 12,\r\n  input: 'i love cat. cat dominates the world.',\r\n  groups: undefined\r\n] 15\r\n*/</span></code></pre></div>\n<br/>\n<p>위와 같이 일치하는 문자열의 위치를 <code>exec</code>을 이용하여 쉽게 찾을 수 있습니다.</p>\n<h2 id=\"test\" style=\"position:relative;\"><a href=\"#test\" aria-label=\"test permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>test()</h2>\n<p>위에서 언급한 <code>exec</code>을 활용해서 정규 표현식을 만족하는지에 대해 판단할 수도 있지만, <code>test</code>를 이용하는 것이 목적에 부합하며, 공식 문서에서도 이를 권장하고 있습니다. 주어진 문자열이 해당 정규 표현식을 만족하는지에 대한 여부를 <code>true/false</code>로 return 합니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// cat 정규 표현식</span>\r\n<span class=\"token keyword\">const</span> catRegExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">cat</span><span class=\"token regex-delimiter\">/</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"i love cat. cat dominates the world.\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\ntrue\r\n*/</span></code></pre></div>\n<br/>\n<p>중요한 것은 위의 예시는 **해당 정규 표현식에 대한 문자열이 포함되어 있다면 <code>true</code>**라는 것입니다. 특정 문자열 형식과 완전히 동일한지에 대한 여부를 판단하기 위해서는 시작과 끝에 대한 정규 표현식을 작성하도록 합시다.</p>\n<h2 id=\"match\" style=\"position:relative;\"><a href=\"#match\" aria-label=\"match permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>match()</h2>\n<p><code>match</code>는 <strong>주어진 문자열이 정규 표현식과 일치하는 부분을 return</strong> 합니다. 어라? <code>exec</code>와의 차이점이 없는 것 같지 않나요? 맞습니다. <code>g flag</code>를 설정하지 않는다면 <code>match</code>는 <code>exec</code>와 동일하게 작동합니다. 그렇다면 <code>g flag</code>를 설정한다면 어떻게 작동할까요? 바로 <strong>매칭되는 부분을 배열로 return</strong> 하게 됩니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// A부터 E까지의 정규 표현식</span>\r\n<span class=\"token keyword\">const</span> alpha <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[A-E]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>alpha<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\n[ 'A', 'B', 'C', 'D', 'E' ]\r\n*/</span></code></pre></div>\n<br/>\n<p>이와 비슷하면서도 다른 <code>matchAll</code>도 존재합니다. <code>matchAll</code>은 단순히 매칭된 값에 대한 배열만을 return 하는 것이 아닌, <strong>capture group에 대한 정보도 같이 담아 return</strong> 합니다.</p>\n<br/>\n<blockquote>\n<p><strong>Capture group</strong></p>\n<ul>\n<li>정규 표현식에서 <code>()</code>로 감싼 그룹</li>\n</ul>\n</blockquote>\n<br/>\n<p>어떻게 동작하는지는 예시를 통해 살펴보겠습니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// cat 정규 표현식</span>\r\n<span class=\"token keyword\">const</span> catRegExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(c(a(t)))</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"i love cat. cat dominates the world.\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">matchAll</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\n[\r\n  [\r\n    'cat',\r\n    'cat',\r\n    'at',\r\n    't',\r\n    index: 7,\r\n    input: 'i love cat. cat dominates the world.',\r\n    groups: undefined\r\n  ],\r\n  [\r\n    'cat',\r\n    'cat',\r\n    'at',\r\n    't',\r\n    index: 12,\r\n    input: 'i love cat. cat dominates the world.',\r\n    groups: undefined\r\n  ]\r\n]\r\n*/</span></code></pre></div>\n<h2 id=\"named-capturing-group\" style=\"position:relative;\"><a href=\"#named-capturing-group\" aria-label=\"named capturing group permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Named Capturing Group</h2>\n<p><strong>이번 정규 표현식 포스팅의 핵심</strong>입니다. 정규 표현식 기능 중 하나로, 정규 표현식 패턴에 매칭된 그룹에 특정한 이름을 주는 것입니다. 이 기능은 아래와 같은 문법으로 사용이 가능합니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(?&lt;name>pattern)</code></pre></div>\n<br/>\n<p>해당 기능을 사용하면 <code>match</code>로 return 받는 array 내부의 <code>group</code> 속성에 <code>name : value</code> 쌍의 프로퍼티로 이루어진 객체로 매칭된 데이터를 받아올 수 있게 됩니다. <strong>정규 표현식으로 단순히 문자열 내의 특정 값을 캐치하는 것에서 끝나는 것이 아닌, 파싱까지 가능하다?</strong>... 정말 마법같은 기능입니다!🪄 이를 바탕으로 예시를 작성하자면 아래와 같습니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 이름, 성, 전화번호가 공백으로 구분된 문자열을</span>\r\n<span class=\"token comment\">// 파싱하기 위한 정규 표현식</span>\r\n<span class=\"token keyword\">const</span> personalInfo <span class=\"token operator\">=</span>\r\n  <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?&lt;firstName>[\\w]+)\\s+(?&lt;lastName>[\\w]+)\\s+(?&lt;number>[\\d]+)</span><span class=\"token regex-delimiter\">/</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Harry Potter 01012345678\"</span>\r\n\r\n<span class=\"token comment\">// match 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>personalInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\n[\r\n  'Harry Potter 01012345678',\r\n  'Harry',\r\n  'Potter',\r\n  '01012345678',\r\n  index: 0,\r\n  input: 'Harry Potter 01012345678',\r\n  groups: [Object: null prototype] {\r\n    firstName: 'Harry',\r\n    lastName: 'Potter',\r\n    number: '01012345678'\r\n  }\r\n]\r\n*/</span>\r\n\r\n<span class=\"token comment\">// 전화번호 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>personalInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\n01012345678\r\n*/</span></code></pre></div>\n<br/>\n<p>정말 너무나도 간편하게 <strong>문자열에서 원하는 부분만 파싱하여 바로 객체 형태로 return</strong> 받을 수 있습니다. 특정 seperator를 기준으로 직접 <code>split</code>을 진행하여 저장했던 이전 방식과 비교할 수 없을 만큼 간단합니다.</p>\n<h2 id=\"search\" style=\"position:relative;\"><a href=\"#search\" aria-label=\"search permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>search()</h2>\n<p><code>search</code>는 <strong>주어진 문자열에서 정규 표현식과 일치하는 가장 첫 번째 부분의 index를 return</strong> 합니다. 찾지 못할 경우에는 <code>-1</code>을 return 합니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// cat 정규표현식</span>\r\n<span class=\"token keyword\">const</span> catRegExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">cat</span><span class=\"token regex-delimiter\">/</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"i love cat. cat dominates the world.\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\n7\r\n*/</span></code></pre></div>\n<h2 id=\"replace\" style=\"position:relative;\"><a href=\"#replace\" aria-label=\"replace permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>replace()</h2>\n<p><code>replace</code>에서도 정규 표현식을 사용할 수 있다는 사실, 알고 계셨나요? <code>replace</code>는 <strong>정규 표현식에 해당하는 문자열을 변경</strong>해줍니다. 예시를 살펴봅시다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// cat 정규표현식</span>\r\n<span class=\"token keyword\">const</span> catRegExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">cat</span><span class=\"token regex-delimiter\">/</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"i love cat. cat dominates the world.\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">,</span> <span class=\"token string\">\"dog\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\ni love dog. cat dominates the world.\r\n*/</span></code></pre></div>\n<br/>\n<p>이와 비슷한 <code>replaceAll</code>이라는 method도 존재합니다. <code>replaceAll</code>은 정규 표현식에 해당하는 모든 부분을 해당 문자열로 교체해줍니다. 단, <code>g flag</code>를 꼭 설정해야 합니다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// cat 정규표현식</span>\r\n<span class=\"token keyword\">const</span> catRegExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">cat</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span>\r\n\r\n<span class=\"token comment\">// test 문자열</span>\r\n<span class=\"token keyword\">const</span> test1 <span class=\"token operator\">=</span> <span class=\"token string\">\"i love cat. cat dominates the world.\"</span>\r\n\r\n<span class=\"token comment\">// 결과 출력</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test1<span class=\"token punctuation\">.</span><span class=\"token function\">replaceAll</span><span class=\"token punctuation\">(</span>catRegExp<span class=\"token punctuation\">,</span> <span class=\"token string\">\"dog\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">/*\r\ni love dog. dog dominates the world.\r\n*/</span></code></pre></div>\n<br/>\n<p>사실 <strong><code>replace</code>에서 인자로 넘겨주는 정규 표현식에 <code>g flag</code>를 설정해주는 것으로 <code>replaceAll</code>과 동일한 동작</strong>을 하도록 할 수 있습니다. 차이점이라면 <code>replaceAll</code>은 <code>g flag</code>가 설정되지 않는다면 오류가 발생한다는 점입니다. 명시적으로 <strong>모두 변경함</strong>을 나타내고 싶다면 <code>replaceAll</code>을 사용하면 되겠습니다.</p>\n<h1 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"autolinkHeader before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Regular_expressions\">MDN web docs 정규 표현식 번역본</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\">RegExp.prototype.exec()</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\">RegExp.prototype.test()</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match\">String.prototype.match()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\">String.prototype.matchAll()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Named_capturing_group\">Named capturing group: (?&#x3C;name>...)</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/search\">String.prototype.search()</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/replace\">String.prototype.replace()</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\">String.prototype.replaceAll()</a></li>\n</ul>"},"previous":{"fields":{"slug":"/boostcamp/challenge-end/"},"frontmatter":{"title":"부스트캠프 웹・모바일 8기 챌린지 수료 회고"}},"next":{"fields":{"slug":"/boostcamp/membership/"},"frontmatter":{"title":"부스트캠프 웹・모바일 8기 멤버십 학습 스프린트 회고"}}},"pageContext":{"id":"e9fda44d-22ad-5f9a-91d3-7c49fd32d599","previousPostId":"60663494-5e4b-5633-b38b-3adcf0c9cef5","nextPostId":"5fd752cb-7509-5513-b451-34d80cb770a3"}},"staticQueryHashes":["4172131656"],"slicesMap":{}}